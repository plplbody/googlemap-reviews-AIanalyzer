{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/firebase/admin.ts"],"sourcesContent":["import * as admin from 'firebase-admin';\r\n\r\nexport function getFirestore() {\r\n    if (!admin.apps.length) {\r\n        admin.initializeApp({\r\n            credential: admin.credential.applicationDefault(),\r\n        });\r\n        admin.firestore().settings({ ignoreUndefinedProperties: true });\r\n    }\r\n    return admin.firestore();\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS;IACZ,IAAI,CAAC,mIAAU,CAAC,MAAM,EAAE;QACpB,4IAAmB,CAAC;YAChB,YAAY,yIAAgB,CAAC,kBAAkB;QACnD;QACA,wIAAe,GAAG,QAAQ,CAAC;YAAE,2BAA2B;QAAK;IACjE;IACA,OAAO,wIAAe;AAC1B"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["file:///app/src/server/services/analyzer.service.ts"],"sourcesContent":["import { VertexAI } from '@google-cloud/vertexai';\r\nimport { getFirestore } from '@/lib/firebase/admin';\r\nimport { Place, AnalysisStatus } from '@/types/schema';\r\n\r\n// Initialize Vertex AI lazily\r\nconst getModel = () => {\r\n    const vertexAI = new VertexAI({\r\n        project: process.env.GOOGLE_CLOUD_PROJECT || 'demo-project',\r\n        location: 'us-central1'\r\n    });\r\n    return vertexAI.getGenerativeModel({ model: 'gemini-2.0-flash-001' });\r\n};\r\n\r\nexport async function analyzePlace(placeId: string): Promise<void> {\r\n    console.log(`Starting analysis for place: ${placeId}`);\r\n\r\n    try {\r\n        // 1. Update status to processing\r\n        await getFirestore().collection('places').doc(placeId).update({\r\n            status: 'processing',\r\n            updatedAt: new Date(),\r\n        });\r\n\r\n        // 2. Fetch reviews\r\n        const doc = await getFirestore().collection('places').doc(placeId).get();\r\n        const placeData = doc.data() as Place;\r\n\r\n        let reviewsText = \"\";\r\n        const MIN_REVIEW_LENGTH = 15;\r\n        let analysisStats = {\r\n            totalReviewsFetched: 0,\r\n            validReviews: 0,\r\n            excludedReviews: 0,\r\n            exclusionRatio: 0\r\n        };\r\n\r\n        if (placeData.reviews && placeData.reviews.length > 0) {\r\n            analysisStats.totalReviewsFetched = placeData.reviews.length;\r\n\r\n            // Filter out short reviews to focus on structured feedback\r\n            const validReviews = placeData.reviews.filter(r => r.length >= MIN_REVIEW_LENGTH);\r\n\r\n            analysisStats.validReviews = validReviews.length;\r\n            analysisStats.excludedReviews = analysisStats.totalReviewsFetched - analysisStats.validReviews;\r\n            analysisStats.exclusionRatio = analysisStats.totalReviewsFetched > 0\r\n                ? analysisStats.excludedReviews / analysisStats.totalReviewsFetched\r\n                : 0;\r\n\r\n            console.log(`Filtered reviews: ${validReviews.length} / ${placeData.reviews.length} (Min length: ${MIN_REVIEW_LENGTH})`);\r\n\r\n            if (validReviews.length > 0) {\r\n                reviewsText = validReviews.join(\"\\n\");\r\n            } else {\r\n                console.log(\"No valid reviews after filtering. Using raw reviews as fallback.\");\r\n                reviewsText = placeData.reviews.join(\"\\n\");\r\n                // In fallback case, we consider all as valid for the prompt, but stats reflect the quality issue\r\n            }\r\n        } else {\r\n            console.log(\"No real reviews found. Using mock reviews for fallback.\");\r\n            const mockReviews = [\r\n                \"The food was amazing, especially the sushi! But the service was a bit slow.\",\r\n                \"Great atmosphere, loved the decor. A bit pricey though.\",\r\n                \"Terrible experience. Rude staff and cold food.\",\r\n                \"Best place in town for a date night. Quiet and romantic.\",\r\n                \"Good value for money. Portions are huge.\",\r\n                \"Perfect for a business dinner. Private rooms available and very attentive service.\",\r\n                \"I went alone and felt very comfortable at the counter.\"\r\n            ];\r\n            reviewsText = mockReviews.join(\"\\n\");\r\n        }\r\n\r\n        // 3. Prepare Detailed Info Context\r\n        const detailedInfo = placeData.detailedInfo || {};\r\n        const detailedInfoText = JSON.stringify(detailedInfo, null, 2);\r\n\r\n        // 4. Call Gemini API\r\n        const prompt = `\r\n      Analyze the following reviews for a restaurant and provide scores (0-5) for Taste, Service, Atmosphere, and Cost.\r\n      Also calculate a \"True Score\" (AI Analysis Score / AI分析スコア) which is a weighted average based on sentiment reliability, and a brief summary.\r\n      \r\n      **CRITICAL INSTRUCTION: The output JSON content MUST BE WRITTEN IN JAPANESE.**\r\n\r\n      **Detailed Place Information (Basic Info Tab):**\r\n      ${detailedInfoText}\r\n\r\n      **IMPORTANT RULES FOR SCORING:**\r\n      1. **NO PRIOR KNOWLEDGE**: Do NOT use any external knowledge about this brand or place. Rely ONLY on the provided reviews and the \"Detailed Place Information\".\r\n      2. **EVIDENCE BASED**: If the reviews do not contain specific information about an axis (e.g., Cost), you MUST assign a score of **3 (Neutral)**. Do not guess.\r\n      3. **STRUCTURED REVIEWS ONLY**: Focus on the logic and reasoning in the reviews. Ignore emotional outbursts without context.\r\n      4. **USE DETAILED INFO**: Use the \"Detailed Place Information\" to refine your scores and usage analysis based on the following logic:\r\n         \r\n         | Category | Field | Value | Impact on Axis | Impact on Usage |\r\n         | :--- | :--- | :--- | :--- | :--- |\r\n         | **Service** | \\`reservable\\` | \\`true\\` | **Service +**: Convenience | **Business/Date +**: Essential. **Group ++**: Vital for organizer. **Solo -**: Hard to enter? |\r\n         | | \\`delivery\\` / \\`takeout\\` | \\`true\\` | **Service +**: Flexibility | **Date -**: If delivery-focused. |\r\n         | | \\`paymentOptions\\` | \\`Cash Only\\` | **Service -**: Inconvenient | **Business/Group -**: Payment friction. |\r\n         | | | \\`Credit / Digital\\` | **Service +**: Convenient | **Business/Group +**: Smooth payment. |\r\n         | **Food/Drink** | \\`servesBreakfast\\` | \\`true\\` | | **Solo +**: Easy entry. |\r\n         | | \\`servesLunch\\` | \\`true\\` | **Cost**: Good Value? | **Solo/Family +**: Casual. **Group +**: Lunch gathering. |\r\n         | | \\`servesDinner\\` | \\`true\\` | | **Date/Business/Group +**: Main use case. |\r\n         | | \\`servesWine\\` / \\`Beer\\` | \\`true\\` | **Atmosphere +**: Dinner vibe | **Date/Business +**. **Group +**: Drinking party. **Family -**: If Bar-like. |\r\n         | **Amenities** | \\`goodForChildren\\` | \\`true\\` | | **Family ++**: Critical. **Business/Date -**: Noise risk. |\r\n         | | \\`goodForGroups\\` | \\`true\\` | **Atmosphere**: Lively | **Group ++**: Best fit. **Business +**: Team dinner. **Date -**: Not intimate. |\r\n         | | \\`restroom\\` | \\`true\\` | **Service +**: Basic comfort | **Group +**: Essential for long stay. |\r\n         | **Price** | \\`priceLevel\\` | \\`High\\` | **Cost -**: Expensive | **Business/Date +**: Luxurious. **Group -**: Not for casual. |\r\n         | | | \\`Low\\` | **Cost +**: Cheap | **Solo/Student +**. **Business/Date -**: Too casual? |\r\n\r\n         **Strictly apply this logic.** If a field is explicitly \\`false\\`, do NOT apply the positive impact. If \\`undefined\\`, ignore.\r\n\r\n      Additionally, provide the following detailed insights:\r\n      **CRITICAL: NATURAL LANGUAGE ONLY**\r\n      - **NEVER** use raw variable names (e.g., \"goodForChildren\", \"reservable\", \"true\", \"false\") in your JSON output strings.\r\n      - **ALWAYS** paraphrase into natural Japanese.\r\n      - Example: \"goodForChildren: false\" -> \"子供連れには向かない可能性があります\" or \"子供向けの設備は明記されていません\".\r\n      - Example: \"reservable: true\" -> \"予約可能です\".\r\n      - Example: \"goodForGroups: Lively\" -> \"団体利用に適した活気ある雰囲気\".\r\n      - This applies to \\`usageSummary\\`, \\`gapReason\\`, \\`summary\\`, and \\`axisAnalysis\\` (pros/cons).\r\n\r\n      1. \"gapReason\": Explain why the \"AI分析スコア\" (True Score) might differ from a typical average rating. Use the term \"AI分析スコア\" in your explanation, NOT \"True Score\".\r\n      2. \"axisAnalysis\": For EACH axis (taste, service, atmosphere, cost), provide:\r\n         - \"pros\": A list of positive points (strings).\r\n         - \"cons\": A list of negative points (strings).\r\n         - \"summary\": A brief summary string.\r\n\r\n      Evaluate the suitability (0-5) for the following scenarios based on the reviews AND detailed info:\r\n      - Business (接待・会食): Is it quiet? Good service? Private rooms? Reservable?\r\n      - Date (デート): Romantic? Good ambiance? Serves wine?\r\n      - Solo (お一人様): Counter seats? Easy to enter alone?\r\n      - Family (家族連れ): Kids friendly? Spacious? Good for children?\r\n      - Group (団体利用): Reservable? Good for groups? Spacious?\r\n\r\n      Also provide a \"usageSummary\" (string): A brief explanation of why these usage scores were assigned, BASED STRICTLY ON THE REVIEWS AND DETAILED INFO.\r\n      - Do NOT include your own opinion or negative inferences if not mentioned in the text.\r\n      - If a specific scenario is not mentioned, do not comment on it.\r\n      - Example: \"Has private rooms suitable for business. Counter seats available.\" (Do NOT say \"Not suitable for families\" if reviews don't say so).\r\n      \r\n      Reviews:\r\n      ${reviewsText}\r\n      \r\n      Output JSON format:\r\n      {\r\n        \"trueScore\": number,\r\n        \"axisScores\": {\r\n          \"taste\": number,\r\n          \"service\": number,\r\n          \"atmosphere\": number,\r\n          \"cost\": number\r\n        },\r\n        \"usageScores\": {\r\n          \"business\": number,\r\n          \"date\": number,\r\n          \"solo\": number,\r\n          \"family\": number,\r\n          \"group\": number\r\n        },\r\n        \"usageSummary\": \"string\",\r\n        \"summary\": \"string\",\r\n        \"gapReason\": \"string\",\r\n        \"axisAnalysis\": {\r\n          \"taste\": { \"pros\": [\"string\"], \"cons\": [\"string\"], \"summary\": \"string\" },\r\n          \"service\": { \"pros\": [\"string\"], \"cons\": [\"string\"], \"summary\": \"string\" },\r\n          \"atmosphere\": { \"pros\": [\"string\"], \"cons\": [\"string\"], \"summary\": \"string\" },\r\n          \"cost\": { \"pros\": [\"string\"], \"cons\": [\"string\"], \"summary\": \"string\" }\r\n        }\r\n      }\r\n    `;\r\n\r\n        const result = await getModel().generateContent(prompt);\r\n        const response = result.response;\r\n        const text = response.candidates?.[0].content.parts[0].text;\r\n\r\n        if (!text) throw new Error(\"No response from Gemini\");\r\n\r\n        // Clean up markdown code blocks if present\r\n        let jsonStr = text.replace(/```json\\n|\\n```/g, \"\");\r\n        // Remove any leading/trailing whitespace\r\n        jsonStr = jsonStr.trim();\r\n\r\n        // Find the first '{' and last '}' to handle potential extra text\r\n        const firstOpen = jsonStr.indexOf('{');\r\n        const lastClose = jsonStr.lastIndexOf('}');\r\n        if (firstOpen !== -1 && lastClose !== -1) {\r\n            jsonStr = jsonStr.substring(firstOpen, lastClose + 1);\r\n        }\r\n\r\n        const analysis = JSON.parse(jsonStr);\r\n\r\n        // 4. Save results to Firestore\r\n        await getFirestore().collection('places').doc(placeId).update({\r\n            status: 'completed',\r\n            trueScore: analysis.trueScore,\r\n            axisScores: analysis.axisScores,\r\n            usageScores: analysis.usageScores,\r\n            usageSummary: analysis.usageSummary || \"\",\r\n            summary: analysis.summary,\r\n            gapReason: analysis.gapReason || \"\",\r\n            axisAnalysis: analysis.axisAnalysis || {},\r\n            analysisStats: analysisStats,\r\n            lastAnalyzedAt: new Date(),\r\n            updatedAt: new Date(),\r\n        });\r\n\r\n        console.log(`Analysis completed for place: ${placeId}`);\r\n\r\n    } catch (error) {\r\n        console.error(`Analysis failed for place: ${placeId}`, error);\r\n        await getFirestore().collection('places').doc(placeId).update({\r\n            status: 'error',\r\n            updatedAt: new Date(),\r\n        });\r\n        throw error;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/queue/client.ts"],"sourcesContent":["import { analyzePlace } from '@/server/services/analyzer.service';\r\n\r\nexport async function enqueueAnalysis(placeId: string) {\r\n    const isDev = process.env.NODE_ENV === 'development';\r\n\r\n    if (isDev) {\r\n        console.log(`[Local] Enqueuing analysis for ${placeId} directly.`);\r\n        try {\r\n            await analyzePlace(placeId);\r\n        } catch (e) {\r\n            console.error(\"Local analysis failed\", e);\r\n        }\r\n    } else {\r\n        console.log(`[Prod] Enqueuing analysis for ${placeId} to Cloud Tasks.`);\r\n\r\n        // Dynamic import to avoid build-time evaluation issues in dev/build\r\n        const { CloudTasksClient } = await import('@google-cloud/tasks');\r\n        const client = new CloudTasksClient();\r\n\r\n        const project = process.env.GOOGLE_CLOUD_PROJECT;\r\n        const queue = 'analysis-queue';\r\n        const location = 'us-central1';\r\n        const url = `https://${process.env.NEXT_PUBLIC_HOST}/api/tasks/analyze`;\r\n\r\n        const parent = client.queuePath(project!, location, queue);\r\n\r\n        const task = {\r\n            httpRequest: {\r\n                httpMethod: 'POST' as const,\r\n                url,\r\n                body: Buffer.from(JSON.stringify({ placeId })).toString('base64'),\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n            },\r\n        };\r\n\r\n        await client.createTask({ parent, task });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,eAAe,gBAAgB,OAAe;IACjD,MAAM,QAAQ,oDAAyB;IAEvC,wCAAW;QACP,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,QAAQ,UAAU,CAAC;QACjE,IAAI;YACA,MAAM,IAAA,gKAAY,EAAC;QACvB,EAAE,OAAO,GAAG;YACR,QAAQ,KAAK,CAAC,yBAAyB;QAC3C;IACJ;;AA2BJ"}},
    {"offset": {"line": 381, "column": 0}, "map": {"version":3,"sources":["file:///app/src/server/actions/place.ts"],"sourcesContent":["'use server';\r\n\r\nimport { GoogleAuth } from 'google-auth-library';\r\nimport { getFirestore } from '@/lib/firebase/admin';\r\nimport { enqueueAnalysis } from '@/lib/queue/client';\r\nimport { Place } from '@/types/schema';\r\n\r\nexport async function searchAndAnalyze(query: string): Promise<string> {\r\n    console.log(`Analyzing place: ${query}`);\r\n    const placeId = query; // In the new flow, query is the placeId\r\n\r\n    const docRef = getFirestore().collection('places').doc(placeId);\r\n    const doc = await docRef.get();\r\n\r\n    if (doc.exists) {\r\n        const data = doc.data() as Place;\r\n        console.log(`Place ${placeId} found. Status: ${data.status}`);\r\n\r\n        // Check for expiration (30 days)\r\n        const now = new Date();\r\n        const updatedAt = data.updatedAt ? (data.updatedAt as any).toDate() : new Date(0); // Handle Firestore Timestamp\r\n        const diffTime = Math.abs(now.getTime() - updatedAt.getTime());\r\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\r\n\r\n        if (diffDays > 30) {\r\n            console.log(`Place ${placeId} data is expired (${diffDays} days old). Re-fetching...`);\r\n            // Fall through to fetch logic\r\n        } else if (data.status === 'error') {\r\n            await enqueueAnalysis(placeId);\r\n            return placeId;\r\n        } else {\r\n            return placeId;\r\n        }\r\n    }\r\n\r\n    // If we are here, it means either doc doesn't exist OR it's expired.\r\n    // We need to fetch from Google Places API.\r\n    console.log(`Fetching fresh data for place ${placeId}...`);\r\n\r\n    try {\r\n        const auth = new GoogleAuth({\r\n            scopes: 'https://www.googleapis.com/auth/cloud-platform'\r\n        });\r\n        const client = await auth.getClient();\r\n        const token = await client.getAccessToken();\r\n\r\n        const baseUrl = `https://places.googleapis.com/v1/places/${placeId}?languageCode=ja`;\r\n        const headers = {\r\n            'Content-Type': 'application/json',\r\n            'Authorization': `Bearer ${token.token}`,\r\n            'X-Goog-FieldMask': 'id,displayName,formattedAddress,rating,userRatingCount,reviews,priceLevel,priceRange,paymentOptions,delivery,takeout,dineIn,reservable,servesBeer,servesWine,servesVegetarianFood,servesCoffee,servesBreakfast,servesLunch,servesDinner,goodForChildren,goodForGroups,restroom,accessibilityOptions'\r\n        };\r\n\r\n        const response = await fetch(baseUrl, { method: 'GET', headers });\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('Google Places API Details Error:', errorText);\r\n            throw new Error(`Google Places API Error: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n        console.log('API Response Data:', JSON.stringify(data, null, 2));\r\n\r\n        // Extract reviews\r\n        const reviews = data.reviews?.map((r: any) => r.text?.text).filter(Boolean) || [];\r\n\r\n        console.log(`Fetched reviews: ${reviews.length}`);\r\n\r\n        const newPlace: Place = {\r\n            id: data.id,\r\n            name: data.displayName?.text || 'Unknown',\r\n            address: data.formattedAddress,\r\n            originalRating: data.rating || 0,\r\n            userRatingsTotal: data.userRatingCount || 0,\r\n            ...(data.priceLevel ? { priceLevel: data.priceLevel } : {}),\r\n            ...(data.priceRange ? { priceRange: data.priceRange } : {}),\r\n            reviews: reviews,\r\n            detailedInfo: {\r\n                paymentOptions: data.paymentOptions,\r\n                serviceOptions: {\r\n                    delivery: data.delivery,\r\n                    takeout: data.takeout,\r\n                    dineIn: data.dineIn,\r\n                    reservable: data.reservable\r\n                },\r\n                offerings: {\r\n                    servesBeer: data.servesBeer,\r\n                    servesWine: data.servesWine,\r\n                    servesVegetarianFood: data.servesVegetarianFood,\r\n                    servesCoffee: data.servesCoffee\r\n                },\r\n                diningOptions: {\r\n                    servesBreakfast: data.servesBreakfast,\r\n                    servesLunch: data.servesLunch,\r\n                    servesDinner: data.servesDinner\r\n                },\r\n                amenities: {\r\n                    restroom: data.restroom,\r\n                    goodForChildren: data.goodForChildren,\r\n                    goodForGroups: data.goodForGroups\r\n                },\r\n            },\r\n            status: 'pending',\r\n            createdAt: doc.exists ? (doc.data() as Place).createdAt : new Date(), // Keep original createdAt if exists\r\n            updatedAt: new Date(),\r\n        };\r\n\r\n        await docRef.set(newPlace);\r\n        await enqueueAnalysis(placeId);\r\n\r\n    } catch (error) {\r\n        console.error('Failed to fetch place details:', error);\r\n        throw error;\r\n    }\r\n\r\n    return placeId;\r\n}\r\n\r\nexport interface PlaceSearchResult {\r\n    id: string;\r\n    name: string;\r\n    rating: number;\r\n    userRatingsTotal: number;\r\n    vicinity?: string;\r\n}\r\n\r\nasync function searchPlacesIdOnly(query: string): Promise<string[]> {\r\n    console.log(`Searching places (ID only) for: ${query}`);\r\n    try {\r\n        const auth = new GoogleAuth({\r\n            scopes: 'https://www.googleapis.com/auth/cloud-platform'\r\n        });\r\n        const client = await auth.getClient();\r\n        const token = await client.getAccessToken();\r\n\r\n        const response = await fetch('https://places.googleapis.com/v1/places:searchText', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'Authorization': `Bearer ${token.token}`,\r\n                'X-Goog-FieldMask': 'places.id'\r\n            },\r\n            body: JSON.stringify({\r\n                textQuery: query,\r\n                languageCode: 'ja',\r\n                maxResultCount: 20\r\n            })\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`Google Places API Error: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n        return data.places?.map((p: any) => p.id) || [];\r\n    } catch (error) {\r\n        console.error('Failed to search places (ID only):', error);\r\n        return [];\r\n    }\r\n}\r\n\r\nexport interface PlaceSearchResponse {\r\n    places: PlaceSearchResult[];\r\n    nextPageToken?: string;\r\n}\r\n\r\nexport async function searchPlaces(query: string, pageToken?: string): Promise<PlaceSearchResponse> {\r\n    console.log(`Searching places list for: ${query}, pageToken: ${pageToken ? 'Yes' : 'No'}`);\r\n\r\n    try {\r\n        // 1. ID Search (Free) - Skip if paging\r\n        // Pagination usually implies we skip the efficient ID-only check because we can't easily map pages to IDs without fetching.\r\n        // Also, cache logic is complex with pagination.\r\n        // For simplicity: If pageToken is present, go straight to API.\r\n        // If no pageToken, we can TRY cache, but we need to know if we have *all* results?\r\n        // Actually, the previous cache logic was \"If we have ALL 20 IDs in cache\".\r\n        // Now valid for first page.\r\n\r\n        let placeIds: string[] = [];\r\n\r\n        // Only do ID search for first page to check cache\r\n        if (!pageToken) {\r\n            placeIds = await searchPlacesIdOnly(query);\r\n            if (placeIds.length === 0 && !pageToken) return { places: [] };\r\n\r\n            // 2. Check Cache (Only for first page)\r\n            const db = getFirestore();\r\n            const placesRef = db.collection('places');\r\n            const cachedPlaces: PlaceSearchResult[] = [];\r\n            let allCached = true;\r\n\r\n            for (const id of placeIds) {\r\n                const doc = await placesRef.doc(id).get();\r\n                if (doc.exists) {\r\n                    const data = doc.data() as Place;\r\n                    // Check expiration (30 days)\r\n                    const now = new Date();\r\n                    const updatedAt = data.updatedAt ? (data.updatedAt as any).toDate() : new Date(0);\r\n                    const diffTime = Math.abs(now.getTime() - updatedAt.getTime());\r\n                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\r\n\r\n                    if (diffDays <= 30 && data.status !== 'error') {\r\n                        cachedPlaces.push({\r\n                            id: data.id,\r\n                            name: data.name,\r\n                            rating: data.originalRating,\r\n                            userRatingsTotal: data.userRatingsTotal,\r\n                            vicinity: data.address\r\n                        });\r\n                    } else {\r\n                        allCached = false;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    allCached = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // 3. Conditional Return (Only if all cached and no page token needed logic?)\r\n            // If we have cached data for the top 20, we return them.\r\n            // Converting cache hits to a \"Next Page\" capable response is tricky because we don't have the nextPageToken from the original API call stored.\r\n            // If we return cached data, the user CANNOT load more because we don't have the token.\r\n            // ERROR: Using cache breaks pagination?\r\n            // \"Load More\" relies on Google's `nextPageToken`. Reviewing flow:\r\n            // Query -> Google API -> Returns items + Token.\r\n            // If we satisfy from Cache, we DON'T have the Token.\r\n            // So if we use Cache, \"Load More\" is impossible unless we re-fetch from API using the original query?\r\n            // Compromise: If we return cached results, we set `nextPageToken` to null.\r\n            // If the user wants \"More\", they might be stuck?\r\n            // Actually, if the cache has 20 items, and we show 20 items...\r\n            // User says \"Load More\". We don't have token.\r\n            // We'd have to trigger a NEW search (API) skipping the first 20? No, Google API doesn't support \"offset\".\r\n            // So, if we want to support \"Load More\", we MUST fetch from API to get the token, OR we accept that \"Cached results have no next page\".\r\n            // Since the user EXPLICITLY requested \"More\", we should prioritize API token availability if possible, OR just disable cache for now to ensure feature works?\r\n            // Or, we return cached results, but if user clicks \"More\" (which won't exist?), they can't.\r\n            // Let's Disable Cache for now to ensure Pagination works correctly as per user request.\r\n            // Or only disable cache if we expect more than 20 results? We don't know.\r\n            // Disabling cache for Search List is safer for this feature.\r\n\r\n            // NOTE: Caching currently disabled for direct search to ensure PAGINATION works (needs fresh nextPageToken).\r\n        }\r\n\r\n        console.log('Fetching fresh data from API...');\r\n\r\n        // 4. Fallback to Full Search (Pro)\r\n        const auth = new GoogleAuth({\r\n            scopes: 'https://www.googleapis.com/auth/cloud-platform'\r\n        });\r\n        const client = await auth.getClient();\r\n        const token = await client.getAccessToken();\r\n\r\n        const requestBody: any = {\r\n            textQuery: query,\r\n            languageCode: 'ja',\r\n            maxResultCount: 20\r\n        };\r\n\r\n        if (pageToken) {\r\n            requestBody.pageToken = pageToken;\r\n        }\r\n\r\n        const response = await fetch('https://places.googleapis.com/v1/places:searchText', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'Authorization': `Bearer ${token.token}`,\r\n                'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.rating,places.userRatingCount,places.reviews,places.priceLevel,places.priceRange,places.paymentOptions,places.delivery,places.takeout,places.dineIn,places.reservable,places.servesBeer,places.servesWine,places.servesVegetarianFood,places.servesCoffee,places.servesBreakfast,places.servesLunch,places.servesDinner,places.goodForChildren,places.goodForGroups,places.restroom,places.accessibilityOptions,nextPageToken'\r\n            },\r\n            body: JSON.stringify(requestBody)\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('Google Places API Error:', errorText);\r\n            throw new Error(`Google Places API Error: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n\r\n        if (!data.places) {\r\n            return { places: [] };\r\n        }\r\n\r\n        const db = getFirestore(); // Ensure DB is initialized\r\n        const placesRef = db.collection('places');\r\n        const batch = db.batch();\r\n        const results: PlaceSearchResult[] = [];\r\n\r\n        for (const placeData of data.places) {\r\n            const reviews = placeData.reviews?.map((r: any) => r.text?.text).filter(Boolean) || [];\r\n\r\n            // Construct full Place object to cache\r\n            // Use Partial<Place> to avoid 'missing property' errors when we deliberately omit 'status' to preserve it\r\n            const newPlace: Partial<Place> = {\r\n                id: placeData.id,\r\n                name: placeData.displayName?.text || 'Unknown',\r\n                address: placeData.formattedAddress,\r\n                originalRating: placeData.rating || 0,\r\n                userRatingsTotal: placeData.userRatingCount || 0,\r\n                ...(placeData.priceLevel ? { priceLevel: placeData.priceLevel } : {}),\r\n                ...(placeData.priceRange ? { priceRange: placeData.priceRange } : {}),\r\n                reviews: reviews,\r\n                detailedInfo: {\r\n                    paymentOptions: placeData.paymentOptions,\r\n                    serviceOptions: {\r\n                        delivery: placeData.delivery,\r\n                        takeout: placeData.takeout,\r\n                        dineIn: placeData.dineIn,\r\n                        reservable: placeData.reservable\r\n                    },\r\n                    offerings: {\r\n                        servesBeer: placeData.servesBeer,\r\n                        servesWine: placeData.servesWine,\r\n                        servesVegetarianFood: placeData.servesVegetarianFood,\r\n                        servesCoffee: placeData.servesCoffee\r\n                    },\r\n                    diningOptions: {\r\n                        servesBreakfast: placeData.servesBreakfast,\r\n                        servesLunch: placeData.servesLunch,\r\n                        servesDinner: placeData.servesDinner\r\n                    },\r\n                    amenities: {\r\n                        restroom: placeData.restroom,\r\n                        goodForChildren: placeData.goodForChildren,\r\n                        goodForGroups: placeData.goodForGroups\r\n                    }\r\n                },\r\n                updatedAt: new Date(),\r\n            };\r\n\r\n            // Prepare for return\r\n            results.push({\r\n                id: placeData.id,\r\n                name: placeData.displayName?.text || 'Unknown',\r\n                rating: placeData.rating || 0,\r\n                userRatingsTotal: placeData.userRatingCount || 0,\r\n                vicinity: placeData.formattedAddress\r\n            });\r\n\r\n            const ref = placesRef.doc(placeData.id);\r\n            // Use merge: true to update existing docs without wiping other fields\r\n            batch.set(ref, newPlace, { merge: true });\r\n        }\r\n\r\n        await batch.commit();\r\n\r\n        // Fire-and-forget analysis for items needing it\r\n        (async () => {\r\n            const refs = results.map(r => placesRef.doc(r.id));\r\n            if (refs.length === 0) return;\r\n\r\n            try {\r\n                const snapshots = await db.getAll(...refs);\r\n\r\n                for (const snap of snapshots) {\r\n                    const d = snap.data() as Place;\r\n                    // Trigger if:\r\n                    // 1. Status is MISSING (new)\r\n                    // 2. OR Status is 'error'\r\n                    // 3. We do NOT re-trigger if 'pending', 'processing', 'completed'.\r\n                    if (!d.status || d.status === 'error') {\r\n                        console.log(`Triggering analysis for ${d.id}`);\r\n                        // Set status to pending to prevent double-queueing? \r\n                        // Ideally yes, but fire-and-forget.\r\n                        enqueueAnalysis(d.id).catch(e => console.error(`Failed to enqueue ${d.id}`, e));\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                console.error(\"Error checking status for analysis trigger\", e);\r\n            }\r\n        })();\r\n\r\n        return {\r\n            places: results,\r\n            nextPageToken: data.nextPageToken\r\n        };\r\n\r\n    } catch (error) {\r\n        console.error('Failed to search places:', error);\r\n        return { places: [] };\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 742, "column": 0}, "map": {"version":3,"sources":["file:///app/src/server/actions/config.ts"],"sourcesContent":["'use server';\r\n\r\nexport async function getGoogleMapsApiKey(): Promise<string> {\r\n    const key = process.env.GOOGLE_MAPS_API_KEY;\r\n    console.log('getGoogleMapsApiKey called. Key exists:', !!key);\r\n    if (!key) {\r\n        console.warn('GOOGLE_MAPS_API_KEY is not set');\r\n        return '';\r\n    }\r\n    return key;\r\n}\r\n"],"names":[],"mappings":";;;;;;;AAEO,eAAe;IAClB,MAAM,MAAM,QAAQ,GAAG,CAAC,mBAAmB;IAC3C,QAAQ,GAAG,CAAC,2CAA2C,CAAC,CAAC;IACzD,IAAI,CAAC,KAAK;QACN,QAAQ,IAAI,CAAC;QACb,OAAO;IACX;IACA,OAAO;AACX;;;IARsB;;AAAA,+OAAA"}},
    {"offset": {"line": 767, "column": 0}, "map": {"version":3,"sources":["file:///app/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {searchPlaces as '605879696842d3dfb20127da930290d765080fe8ed'} from 'ACTIONS_MODULE0'\nexport {searchAndAnalyze as '40432db7ac9dada39e81ca58c7626c6d95dc44f068'} from 'ACTIONS_MODULE0'\nexport {getGoogleMapsApiKey as '00ed017af06828ff862996b1649f3d8a7bb72057e6'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AAEA"}}]
}