{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 130, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/firebase/admin.ts"],"sourcesContent":["import * as admin from 'firebase-admin';\r\n\r\nexport function getFirestore() {\r\n    if (!admin.apps.length) {\r\n        admin.initializeApp({\r\n            credential: admin.credential.applicationDefault(),\r\n        });\r\n    }\r\n    return admin.firestore();\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,SAAS;IACZ,IAAI,CAAC,mIAAU,CAAC,MAAM,EAAE;QACpB,4IAAmB,CAAC;YAChB,YAAY,yIAAgB,CAAC,kBAAkB;QACnD;IACJ;IACA,OAAO,wIAAe;AAC1B"}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///app/src/server/services/analyzer.service.ts"],"sourcesContent":["import { VertexAI } from '@google-cloud/vertexai';\r\nimport { getFirestore } from '@/lib/firebase/admin';\r\nimport { Place, AnalysisStatus } from '@/types/schema';\r\n\r\n// Initialize Vertex AI lazily\r\nconst getModel = () => {\r\n    const vertexAI = new VertexAI({\r\n        project: process.env.GOOGLE_CLOUD_PROJECT || 'demo-project',\r\n        location: 'us-central1'\r\n    });\r\n    return vertexAI.getGenerativeModel({ model: 'gemini-2.0-flash-001' });\r\n};\r\n\r\nexport async function analyzePlace(placeId: string): Promise<void> {\r\n    console.log(`Starting analysis for place: ${placeId}`);\r\n\r\n    try {\r\n        // 1. Update status to processing\r\n        await getFirestore().collection('places').doc(placeId).update({\r\n            status: 'processing',\r\n            updatedAt: new Date(),\r\n        });\r\n\r\n        // 2. Fetch reviews\r\n        const doc = await getFirestore().collection('places').doc(placeId).get();\r\n        const placeData = doc.data() as Place;\r\n\r\n        let reviewsText = \"\";\r\n        const MIN_REVIEW_LENGTH = 15;\r\n        let analysisStats = {\r\n            totalReviewsFetched: 0,\r\n            validReviews: 0,\r\n            excludedReviews: 0,\r\n            exclusionRatio: 0\r\n        };\r\n\r\n        if (placeData.reviews && placeData.reviews.length > 0) {\r\n            analysisStats.totalReviewsFetched = placeData.reviews.length;\r\n\r\n            // Filter out short reviews to focus on structured feedback\r\n            const validReviews = placeData.reviews.filter(r => r.length >= MIN_REVIEW_LENGTH);\r\n\r\n            analysisStats.validReviews = validReviews.length;\r\n            analysisStats.excludedReviews = analysisStats.totalReviewsFetched - analysisStats.validReviews;\r\n            analysisStats.exclusionRatio = analysisStats.totalReviewsFetched > 0\r\n                ? analysisStats.excludedReviews / analysisStats.totalReviewsFetched\r\n                : 0;\r\n\r\n            console.log(`Filtered reviews: ${validReviews.length} / ${placeData.reviews.length} (Min length: ${MIN_REVIEW_LENGTH})`);\r\n\r\n            if (validReviews.length > 0) {\r\n                reviewsText = validReviews.join(\"\\n\");\r\n            } else {\r\n                console.log(\"No valid reviews after filtering. Using raw reviews as fallback.\");\r\n                reviewsText = placeData.reviews.join(\"\\n\");\r\n                // In fallback case, we consider all as valid for the prompt, but stats reflect the quality issue\r\n            }\r\n        } else {\r\n            console.log(\"No real reviews found. Using mock reviews for fallback.\");\r\n            const mockReviews = [\r\n                \"The food was amazing, especially the sushi! But the service was a bit slow.\",\r\n                \"Great atmosphere, loved the decor. A bit pricey though.\",\r\n                \"Terrible experience. Rude staff and cold food.\",\r\n                \"Best place in town for a date night. Quiet and romantic.\",\r\n                \"Good value for money. Portions are huge.\",\r\n                \"Perfect for a business dinner. Private rooms available and very attentive service.\",\r\n                \"I went alone and felt very comfortable at the counter.\"\r\n            ];\r\n            reviewsText = mockReviews.join(\"\\n\");\r\n        }\r\n\r\n        // 3. Call Gemini API\r\n        const prompt = `\r\n      Analyze the following reviews for a restaurant and provide scores (0-5) for Taste, Service, Atmosphere, and Cost.\r\n      Also calculate a \"True Score\" (AI Analysis Score / AI分析スコア) which is a weighted average based on sentiment reliability, and a brief summary.\r\n      \r\n      **CRITICAL INSTRUCTION: The output JSON content MUST BE WRITTEN IN JAPANESE.**\r\n\r\n      **IMPORTANT RULES FOR SCORING:**\r\n      1. **NO PRIOR KNOWLEDGE**: Do NOT use any external knowledge about this brand or place. Rely ONLY on the provided reviews.\r\n      2. **EVIDENCE BASED**: If the reviews do not contain specific information about an axis (e.g., Cost), you MUST assign a score of **3 (Neutral)**. Do not guess.\r\n      3. **STRUCTURED REVIEWS ONLY**: Focus on the logic and reasoning in the reviews. Ignore emotional outbursts without context.\r\n\r\n      Additionally, provide the following detailed insights:\r\n      1. \"gapReason\": Explain why the \"AI分析スコア\" (True Score) might differ from a typical average rating. Use the term \"AI分析スコア\" in your explanation, NOT \"True Score\".\r\n      2. \"axisAnalysis\": For EACH axis (taste, service, atmosphere, cost), provide:\r\n         - \"pros\": A list of positive points (strings).\r\n         - \"cons\": A list of negative points (strings).\r\n         - \"summary\": A brief summary string.\r\n\r\n      Evaluate the suitability (0-5) for the following scenarios based on the reviews:\r\n      - Business (接待・会食): Is it quiet? Good service? Private rooms?\r\n      - Date (デート): Romantic? Good ambiance?\r\n      - Solo (お一人様): Counter seats? Easy to enter alone?\r\n      - Solo (お一人様): Counter seats? Easy to enter alone?\r\n      - Family (家族連れ): Kids friendly? Spacious?\r\n      \r\n      Also provide a \"usageSummary\" (string): A brief explanation of why these usage scores were assigned, BASED STRICTLY ON THE REVIEWS.\r\n      - Do NOT include your own opinion or negative inferences if not mentioned in the text.\r\n      - If a specific scenario is not mentioned, do not comment on it.\r\n      - Example: \"Has private rooms suitable for business. Counter seats available.\" (Do NOT say \"Not suitable for families\" if reviews don't say so).\r\n      \r\n      Reviews:\r\n      ${reviewsText}\r\n      \r\n      Output JSON format:\r\n      {\r\n        \"trueScore\": number,\r\n        \"axisScores\": {\r\n          \"taste\": number,\r\n          \"service\": number,\r\n          \"atmosphere\": number,\r\n          \"cost\": number\r\n        },\r\n        \"usageScores\": {\r\n          \"business\": number,\r\n          \"date\": number,\r\n          \"solo\": number,\r\n          \"family\": number\r\n        },\r\n        \"usageSummary\": \"string\",\r\n        \"summary\": \"string\",\r\n        \"gapReason\": \"string\",\r\n        \"axisAnalysis\": {\r\n          \"taste\": { \"pros\": [\"string\"], \"cons\": [\"string\"], \"summary\": \"string\" },\r\n          \"service\": { \"pros\": [\"string\"], \"cons\": [\"string\"], \"summary\": \"string\" },\r\n          \"atmosphere\": { \"pros\": [\"string\"], \"cons\": [\"string\"], \"summary\": \"string\" },\r\n          \"cost\": { \"pros\": [\"string\"], \"cons\": [\"string\"], \"summary\": \"string\" }\r\n        }\r\n      }\r\n    `;\r\n\r\n        const result = await getModel().generateContent(prompt);\r\n        const response = result.response;\r\n        const text = response.candidates?.[0].content.parts[0].text;\r\n\r\n        if (!text) throw new Error(\"No response from Gemini\");\r\n\r\n        // Clean up markdown code blocks if present\r\n        let jsonStr = text.replace(/```json\\n|\\n```/g, \"\");\r\n        // Remove any leading/trailing whitespace\r\n        jsonStr = jsonStr.trim();\r\n\r\n        // Find the first '{' and last '}' to handle potential extra text\r\n        const firstOpen = jsonStr.indexOf('{');\r\n        const lastClose = jsonStr.lastIndexOf('}');\r\n        if (firstOpen !== -1 && lastClose !== -1) {\r\n            jsonStr = jsonStr.substring(firstOpen, lastClose + 1);\r\n        }\r\n\r\n        const analysis = JSON.parse(jsonStr);\r\n\r\n        // 4. Save results to Firestore\r\n        await getFirestore().collection('places').doc(placeId).update({\r\n            status: 'completed',\r\n            trueScore: analysis.trueScore,\r\n            axisScores: analysis.axisScores,\r\n            usageScores: analysis.usageScores,\r\n            usageSummary: analysis.usageSummary || \"\",\r\n            summary: analysis.summary,\r\n            gapReason: analysis.gapReason || \"\",\r\n            axisAnalysis: analysis.axisAnalysis || {},\r\n            analysisStats: analysisStats,\r\n            lastAnalyzedAt: new Date(),\r\n            updatedAt: new Date(),\r\n        });\r\n\r\n        console.log(`Analysis completed for place: ${placeId}`);\r\n\r\n    } catch (error) {\r\n        console.error(`Analysis failed for place: ${placeId}`, error);\r\n        await getFirestore().collection('places').doc(placeId).update({\r\n            status: 'error',\r\n            updatedAt: new Date(),\r\n        });\r\n        throw error;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":["file:///app/src/lib/queue/client.ts"],"sourcesContent":["import { analyzePlace } from '@/server/services/analyzer.service';\r\n\r\nexport async function enqueueAnalysis(placeId: string) {\r\n    const isDev = process.env.NODE_ENV === 'development';\r\n\r\n    if (isDev) {\r\n        console.log(`[Local] Enqueuing analysis for ${placeId} directly.`);\r\n        try {\r\n            await analyzePlace(placeId);\r\n        } catch (e) {\r\n            console.error(\"Local analysis failed\", e);\r\n        }\r\n    } else {\r\n        console.log(`[Prod] Enqueuing analysis for ${placeId} to Cloud Tasks.`);\r\n\r\n        // Dynamic import to avoid build-time evaluation issues in dev/build\r\n        const { CloudTasksClient } = await import('@google-cloud/tasks');\r\n        const client = new CloudTasksClient();\r\n\r\n        const project = process.env.GOOGLE_CLOUD_PROJECT;\r\n        const queue = 'analysis-queue';\r\n        const location = 'us-central1';\r\n        const url = `https://${process.env.NEXT_PUBLIC_HOST}/api/tasks/analyze`;\r\n\r\n        const parent = client.queuePath(project!, location, queue);\r\n\r\n        const task = {\r\n            httpRequest: {\r\n                httpMethod: 'POST' as const,\r\n                url,\r\n                body: Buffer.from(JSON.stringify({ placeId })).toString('base64'),\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n            },\r\n        };\r\n\r\n        await client.createTask({ parent, task });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,eAAe,gBAAgB,OAAe;IACjD,MAAM,QAAQ,oDAAyB;IAEvC,wCAAW;QACP,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,QAAQ,UAAU,CAAC;QACjE,IAAI;YACA,MAAM,IAAA,gKAAY,EAAC;QACvB,EAAE,OAAO,GAAG;YACR,QAAQ,KAAK,CAAC,yBAAyB;QAC3C;IACJ;;AA2BJ"}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":["file:///app/src/server/actions/place.ts"],"sourcesContent":["'use server';\r\n\r\nimport { GoogleAuth } from 'google-auth-library';\r\n\r\nimport { getFirestore } from '@/lib/firebase/admin';\r\nimport { enqueueAnalysis } from '@/lib/queue/client';\r\nimport { Place } from '@/types/schema';\r\n\r\nexport async function searchAndAnalyze(query: string): Promise<string> {\r\n    console.log(`Analyzing place: ${query}`);\r\n    const placeId = query; // In the new flow, query is the placeId\r\n\r\n    const docRef = getFirestore().collection('places').doc(placeId);\r\n    const doc = await docRef.get();\r\n\r\n    if (doc.exists) {\r\n        const data = doc.data() as Place;\r\n        console.log(`Place ${placeId} found. Status: ${data.status}`);\r\n\r\n        // Check for expiration (30 days)\r\n        const now = new Date();\r\n        const updatedAt = data.updatedAt ? (data.updatedAt as any).toDate() : new Date(0); // Handle Firestore Timestamp\r\n        const diffTime = Math.abs(now.getTime() - updatedAt.getTime());\r\n        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\r\n\r\n        if (diffDays > 30) {\r\n            console.log(`Place ${placeId} data is expired (${diffDays} days old). Re-fetching...`);\r\n            // Fall through to fetch logic\r\n        } else if (data.status === 'error') {\r\n            await enqueueAnalysis(placeId);\r\n            return placeId;\r\n        } else {\r\n            return placeId;\r\n        }\r\n    }\r\n\r\n    // If we are here, it means either doc doesn't exist OR it's expired.\r\n    // We need to fetch from Google Places API.\r\n    console.log(`Fetching fresh data for place ${placeId}...`);\r\n\r\n    try {\r\n        const auth = new GoogleAuth({\r\n            scopes: 'https://www.googleapis.com/auth/cloud-platform'\r\n        });\r\n        const client = await auth.getClient();\r\n        const token = await client.getAccessToken();\r\n\r\n        const baseUrl = `https://places.googleapis.com/v1/places/${placeId}?languageCode=ja`;\r\n        const headers = {\r\n            'Content-Type': 'application/json',\r\n            'Authorization': `Bearer ${token.token}`,\r\n            'X-Goog-FieldMask': 'id,displayName,formattedAddress,rating,userRatingCount,reviews,priceLevel,priceRange'\r\n        };\r\n\r\n        const response = await fetch(baseUrl, { method: 'GET', headers });\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('Google Places API Details Error:', errorText);\r\n            throw new Error(`Google Places API Error: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n        console.log('API Response Data:', JSON.stringify(data, null, 2));\r\n\r\n        // Extract reviews\r\n        const reviews = data.reviews?.map((r: any) => r.text?.text).filter(Boolean) || [];\r\n\r\n        console.log(`Fetched reviews: ${reviews.length}`);\r\n\r\n        const newPlace: Place = {\r\n            id: data.id,\r\n            name: data.displayName?.text || 'Unknown',\r\n            address: data.formattedAddress,\r\n            originalRating: data.rating || 0,\r\n            userRatingsTotal: data.userRatingCount || 0,\r\n            ...(data.priceLevel ? { priceLevel: data.priceLevel } : {}),\r\n            ...(data.priceRange ? { priceRange: data.priceRange } : {}),\r\n            reviews: reviews,\r\n            status: 'pending',\r\n            createdAt: doc.exists ? (doc.data() as Place).createdAt : new Date(), // Keep original createdAt if exists\r\n            updatedAt: new Date(),\r\n        };\r\n\r\n        await docRef.set(newPlace);\r\n        await enqueueAnalysis(placeId);\r\n\r\n    } catch (error) {\r\n        console.error('Failed to fetch place details:', error);\r\n        throw error;\r\n    }\r\n\r\n    return placeId;\r\n}\r\n\r\nexport interface PlaceSearchResult {\r\n    id: string;\r\n    name: string;\r\n    rating: number;\r\n    userRatingsTotal: number;\r\n    vicinity?: string;\r\n}\r\n\r\nexport async function searchPlaces(query: string): Promise<PlaceSearchResult[]> {\r\n    console.log(`Searching places list for: ${query}`);\r\n\r\n    try {\r\n        const auth = new GoogleAuth({\r\n            scopes: 'https://www.googleapis.com/auth/cloud-platform'\r\n        });\r\n        const client = await auth.getClient();\r\n        const token = await client.getAccessToken();\r\n\r\n        const response = await fetch('https://places.googleapis.com/v1/places:searchText', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'Authorization': `Bearer ${token.token}`,\r\n                'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.rating,places.userRatingCount'\r\n            },\r\n            body: JSON.stringify({\r\n                textQuery: query,\r\n                languageCode: 'ja',\r\n                maxResultCount: 10\r\n            })\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const errorText = await response.text();\r\n            console.error('Google Places API Error:', errorText);\r\n            throw new Error(`Google Places API Error: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n\r\n        if (!data.places) {\r\n            return [];\r\n        }\r\n\r\n        return data.places.map((place: any) => ({\r\n            id: place.id,\r\n            name: place.displayName?.text || 'Unknown',\r\n            rating: place.rating || 0,\r\n            userRatingsTotal: place.userRatingCount || 0,\r\n            vicinity: place.formattedAddress\r\n        }));\r\n\r\n    } catch (error) {\r\n        console.error('Failed to search places:', error);\r\n        // Fallback to empty list or rethrow depending on UX preference\r\n        // For now, return empty list to avoid crashing UI\r\n        return [];\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;AAEA;AAEA;AACA;;;;;;AAGO,eAAe,iBAAiB,KAAa;IAChD,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,OAAO;IACvC,MAAM,UAAU,OAAO,wCAAwC;IAE/D,MAAM,SAAS,IAAA,+IAAY,IAAG,UAAU,CAAC,UAAU,GAAG,CAAC;IACvD,MAAM,MAAM,MAAM,OAAO,GAAG;IAE5B,IAAI,IAAI,MAAM,EAAE;QACZ,MAAM,OAAO,IAAI,IAAI;QACrB,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,QAAQ,gBAAgB,EAAE,KAAK,MAAM,EAAE;QAE5D,iCAAiC;QACjC,MAAM,MAAM,IAAI;QAChB,MAAM,YAAY,KAAK,SAAS,GAAG,AAAC,KAAK,SAAS,CAAS,MAAM,KAAK,IAAI,KAAK,IAAI,6BAA6B;QAChH,MAAM,WAAW,KAAK,GAAG,CAAC,IAAI,OAAO,KAAK,UAAU,OAAO;QAC3D,MAAM,WAAW,KAAK,IAAI,CAAC,WAAW,CAAC,OAAO,KAAK,KAAK,EAAE;QAE1D,IAAI,WAAW,IAAI;YACf,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,QAAQ,kBAAkB,EAAE,SAAS,0BAA0B,CAAC;QACrF,8BAA8B;QAClC,OAAO,IAAI,KAAK,MAAM,KAAK,SAAS;YAChC,MAAM,IAAA,gJAAe,EAAC;YACtB,OAAO;QACX,OAAO;YACH,OAAO;QACX;IACJ;IAEA,qEAAqE;IACrE,2CAA2C;IAC3C,QAAQ,GAAG,CAAC,CAAC,8BAA8B,EAAE,QAAQ,GAAG,CAAC;IAEzD,IAAI;QACA,MAAM,OAAO,IAAI,gLAAU,CAAC;YACxB,QAAQ;QACZ;QACA,MAAM,SAAS,MAAM,KAAK,SAAS;QACnC,MAAM,QAAQ,MAAM,OAAO,cAAc;QAEzC,MAAM,UAAU,CAAC,wCAAwC,EAAE,QAAQ,gBAAgB,CAAC;QACpF,MAAM,UAAU;YACZ,gBAAgB;YAChB,iBAAiB,CAAC,OAAO,EAAE,MAAM,KAAK,EAAE;YACxC,oBAAoB;QACxB;QAEA,MAAM,WAAW,MAAM,MAAM,SAAS;YAAE,QAAQ;YAAO;QAAQ;QAE/D,IAAI,CAAC,SAAS,EAAE,EAAE;YACd,MAAM,YAAY,MAAM,SAAS,IAAI;YACrC,QAAQ,KAAK,CAAC,oCAAoC;YAClD,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,SAAS,UAAU,EAAE;QACrE;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAChC,QAAQ,GAAG,CAAC,sBAAsB,KAAK,SAAS,CAAC,MAAM,MAAM;QAE7D,kBAAkB;QAClB,MAAM,UAAU,KAAK,OAAO,EAAE,IAAI,CAAC,IAAW,EAAE,IAAI,EAAE,MAAM,OAAO,YAAY,EAAE;QAEjF,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,QAAQ,MAAM,EAAE;QAEhD,MAAM,WAAkB;YACpB,IAAI,KAAK,EAAE;YACX,MAAM,KAAK,WAAW,EAAE,QAAQ;YAChC,SAAS,KAAK,gBAAgB;YAC9B,gBAAgB,KAAK,MAAM,IAAI;YAC/B,kBAAkB,KAAK,eAAe,IAAI;YAC1C,GAAI,KAAK,UAAU,GAAG;gBAAE,YAAY,KAAK,UAAU;YAAC,IAAI,CAAC,CAAC;YAC1D,GAAI,KAAK,UAAU,GAAG;gBAAE,YAAY,KAAK,UAAU;YAAC,IAAI,CAAC,CAAC;YAC1D,SAAS;YACT,QAAQ;YACR,WAAW,IAAI,MAAM,GAAG,AAAC,IAAI,IAAI,GAAa,SAAS,GAAG,IAAI;YAC9D,WAAW,IAAI;QACnB;QAEA,MAAM,OAAO,GAAG,CAAC;QACjB,MAAM,IAAA,gJAAe,EAAC;IAE1B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,kCAAkC;QAChD,MAAM;IACV;IAEA,OAAO;AACX;AAUO,eAAe,aAAa,KAAa;IAC5C,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,OAAO;IAEjD,IAAI;QACA,MAAM,OAAO,IAAI,gLAAU,CAAC;YACxB,QAAQ;QACZ;QACA,MAAM,SAAS,MAAM,KAAK,SAAS;QACnC,MAAM,QAAQ,MAAM,OAAO,cAAc;QAEzC,MAAM,WAAW,MAAM,MAAM,sDAAsD;YAC/E,QAAQ;YACR,SAAS;gBACL,gBAAgB;gBAChB,iBAAiB,CAAC,OAAO,EAAE,MAAM,KAAK,EAAE;gBACxC,oBAAoB;YACxB;YACA,MAAM,KAAK,SAAS,CAAC;gBACjB,WAAW;gBACX,cAAc;gBACd,gBAAgB;YACpB;QACJ;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YACd,MAAM,YAAY,MAAM,SAAS,IAAI;YACrC,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,SAAS,UAAU,EAAE;QACrE;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,CAAC,KAAK,MAAM,EAAE;YACd,OAAO,EAAE;QACb;QAEA,OAAO,KAAK,MAAM,CAAC,GAAG,CAAC,CAAC,QAAe,CAAC;gBACpC,IAAI,MAAM,EAAE;gBACZ,MAAM,MAAM,WAAW,EAAE,QAAQ;gBACjC,QAAQ,MAAM,MAAM,IAAI;gBACxB,kBAAkB,MAAM,eAAe,IAAI;gBAC3C,UAAU,MAAM,gBAAgB;YACpC,CAAC;IAEL,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,+DAA+D;QAC/D,kDAAkD;QAClD,OAAO,EAAE;IACb;AACJ;;;IAjJsB;IA+FA;;AA/FA,+OAAA;AA+FA,+OAAA"}},
    {"offset": {"line": 485, "column": 0}, "map": {"version":3,"sources":["file:///app/src/server/actions/config.ts"],"sourcesContent":["'use server';\r\n\r\nexport async function getGoogleMapsApiKey(): Promise<string> {\r\n    const key = process.env.GOOGLE_MAPS_API_KEY;\r\n    console.log('getGoogleMapsApiKey called. Key exists:', !!key);\r\n    if (!key) {\r\n        console.warn('GOOGLE_MAPS_API_KEY is not set');\r\n        return '';\r\n    }\r\n    return key;\r\n}\r\n"],"names":[],"mappings":";;;;;;;AAEO,eAAe;IAClB,MAAM,MAAM,QAAQ,GAAG,CAAC,mBAAmB;IAC3C,QAAQ,GAAG,CAAC,2CAA2C,CAAC,CAAC;IACzD,IAAI,CAAC,KAAK;QACN,QAAQ,IAAI,CAAC;QACb,OAAO;IACX;IACA,OAAO;AACX;;;IARsB;;AAAA,+OAAA"}},
    {"offset": {"line": 510, "column": 0}, "map": {"version":3,"sources":["file:///app/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {searchPlaces as '402676949e386eb465274f22e78aff102d604150ce'} from 'ACTIONS_MODULE0'\nexport {searchAndAnalyze as '4026175afd116980ff49212b23b51e5c602a2b34b4'} from 'ACTIONS_MODULE0'\nexport {getGoogleMapsApiKey as '00f18128d57cb9015a1bbd473d52a1a360522b1043'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AAEA"}}]
}